# Python program to illustrate
# closures
# i___ log____
#
# l___.b_C_(f_- example.log  l_-l_.I____
#
#
# ___ logger func
#     ___ log_func 0args
#         l__.i_|*Running *||* w__ arguments ||*_fu__;--n__; args||
#         print f__ 0args
#         # Necessary for closure to work (returning WITHOUT parenthesis)
#
#     r_ l___fu__
#
#
# ___ add x y
#     r__ x + y
#
#
# ___ sub x y
#     r__ x - y
#
#
# add_logger _ logger add
# sub_logger _ logger sub
#
# add_logger 3 3
# add_logger 4 5
#
# sub_logger 10 5
# sub_logger 20 10

# When and why to use Closures:
#
#     As closures are used as callback functions, they provide some sort of data hiding. T
#     his helps us to reduce the use of global variables.
#     When we have few functions in our code, closures prove to be efficient way.
#     But if we need to have many functions, then go for class (OOP).
